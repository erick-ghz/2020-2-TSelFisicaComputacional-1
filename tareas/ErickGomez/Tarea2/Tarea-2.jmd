
# TEMAS SELECTOS DE FÍSICA COMPUTACIONAL 1, 2020-2
### Erick Alexis Gómez Hernández

# Tarea 2




> Envío inicial del PR: **27 de marzo**.
>
> Aceptación PR *final*: **3 de abril**.

**NOTA**: Esta tarea incluye generar varias imágenes; no es necesario que las incluyan en su entrega, pero sí debe ser posible generarlas a partir de lo que entreguen.

## Ejercicio 1

Describan la dinámica de varias órbitas para los siguientes mapeos, usando distintos colores para distintas órbitas, en una misma gráfica. Interesa entre otras cosas saber cuántos puntos fijos tiene el mapeo y cómo es la dinámica cerca de dichos puntos.

(a) $M_1(x) = \frac{1}{3x}$.

(b) $M_2(x) = -\frac{x^5}{5}$.

(c) $M_3(x) = \frac{x}{2}-2$.

(d) $M_4(x) = x-x^2$.

```julia
using Plots
gr(), pyplot()
```

```julia
# Definición de las funciones
M1(x) = 1/(3x)
M2(x) = -x^5/5
M3(x) = x/2 - 2
M4(x) = x - x^2
```

```julia
"""
mapear(F :: Function, x0 :: T, n :: Int), {T <: Real} \n

Devuelve un vector de 'n' iteraciones de la función 'F' con condición inicial x0.
"""
function mapear(F::Function, x0::T, n::Int) where {T <: Real}
    iteraciones = Float64[]
    push!(iteraciones, x0)
    
    for i in 1:n
        x0 = F(x0)
        push!(iteraciones, x0)
    end
    
    return iteraciones
end
```

```julia
"""
analisis_grafico(F::Function, x0::Float64, n::Int, limx = (-20,20), limy = (-20,20);  titulo = "F(x)", lab = "") \n

Dibuja la órbita de 'n' iteraciones de una función 'F' a partir de la condición inicial 'x0'.
"""

function analisis_grafico(F::Function, x0::Float64, n::Int, limx = (-20,20), limy = (-20,20);  titulo = "F(x)", lab = "")    
    x1 = F(x0)    # primera iteración
    I = limx[1]:1/100:limx[end] # 'rango' para graficar F
    X = Float64[] # vector abcisas de la órbita
    Y = Float64[] # vector ordenadas de la órbita
    
    p = plot(I, F.(I), title = titulo, l = 1.5, xlims = limx, ylims = limy, label = "F(x)")   
    plot!(x -> x, l = 1.5, grid = false, label = "x") # gráfica de 'F'
    push!(X, x0)
    push!(X, x0)
    push!(X, x1)
    push!(Y, zero(x0))
    push!(Y, x1)
    push!(Y, x1)
    
    for i in 1 : n-1
        x0 = x1
        x1 = F(x0)
        push!(X, x0)
        push!(X, x1)
        push!(Y, x1)
        push!(Y, x1)
    end
    
    plot!(X,Y, m = :circle, ms = 3, mc = :orange,
        l = :dash, lc = :orange, label = lab)
    return p

end
```

```julia
"""
Similar a 'analisis_grafico' pero que además permite permite sobreponer una órbita sobre otra.
"""

function analisis_grafico!(F::Function, x0::Float64, n::Int, col = :red1; lab = "x0")    
    x1 = F(x0)   
    X = Float64[]
    Y = Float64[]
    
    push!(X, x0)
    push!(X, x0)
    push!(X, x1)
    push!(Y, zero(x0))
    push!(Y, x1)
    push!(Y, x1)
    
    for i in 1 : n-1
        x0 = x1
        x1 = F(x0)
        push!(X, x0)
        push!(X, x1)
        push!(Y, x1)
        push!(Y, x1)
    end
    
    p = plot!(X,Y, m = :circle, ms = 3, mc = col, l = :dash, lc = col, label = lab)
    
    return p
end
```

* Órbitas para $ M_1(x) = \frac{1}{3x} $

```julia
n = 20          # iteraciones
X0 = 10*rand(4) # x0 ∈ [0,10]

analisis_grafico(M1, X0[1], n, # función, condicion inicial, iteraciones  
    (0, maximum(X0)+1), # límites en x
    (0, maximum(X0)+1); # límites en y
    titulo = "Órbitas de F(x) = 1/(3x)", # título de todo el plot
    lab    = "$(X0[1])")                 # etiqueta de condción inicial   
analisis_grafico!(M1, X0[2], n, :red2;   lab = "$(X0[2])")
analisis_grafico!(M1, X0[3], n, :green;  lab = "$(X0[3])")
analisis_grafico!(M1, X0[4], n, :purple; lab = "$(X0[4])")
```

```julia
n = 15           # iteraciones
X0 = -10*rand(4) # x0 ∈ [-10,0]

analisis_grafico(M1, X0[1], n, 
    (minimum(X0)-1,2), 
    (minimum(X0)-1,2); 
    titulo = "Órbitas de F(x) = 1/(3x)",
    lab    = "$(X0[1])")
analisis_grafico!(M1, X0[2], n, :red2;   lab = "$(X0[2])")
analisis_grafico!(M1, X0[3], n, :green;  lab = "$(X0[3])")
analisis_grafico!(M1, X0[4], n, :purple; lab = "$(X0[4])")
```

Se nota que todos los puntos son de periodo dos (excepto los puntos fijos que se observan), por lo que serán mapeados solamente a dos valores y no es posible converger gráficamente a algún punto. Analíticamente  el punto fijo es:

$$ \frac{1}{3x} = x \quad\Rightarrow\quad x = \pm \frac{1}{\sqrt{3}} $$

* $ M_2(x) = -\frac{x^5}{5} $

```julia
n = 20                # iteraciones
X0 = 2*rand(6) .- 1.0 # x0 ∈ [-1,1]
a = 1.1

analisis_grafico(M2, X0[1], n, 
    (-a, a), 
    (M2(a),M2(-a)); 
    titulo = "Órbitas de F(x) = -x^5/5",
    lab    = "$(X0[1])")
analisis_grafico!(M2, X0[2], n, :red2;   lab = "$(X0[2])")
analisis_grafico!(M2, X0[3], n, :green;  lab = "$(X0[3])")
analisis_grafico!(M2, X0[4], n, :purple; lab = "$(X0[4])")
analisis_grafico!(M2, X0[5], n, :blue; lab = "$(X0[5])")
analisis_grafico!(M2, X0[5], n, :blue4; lab = "$(X0[6])")
```

```julia
analisis_grafico(M2, 1.4, n, 
    (-10*a, 5*a), 
    (5*M2(a),M2(-a)); 
    titulo = "Órbitas de F(x) = -x^5/5")#,
    #lab    = "$(X0[1])")
```

```julia
#mapear(M2, 1.493, 30)
```

Las órbitas con $x_0\in[-1,1]$ convergen al punto $x=0$ por lo que este es un punto fijo atractor de éstas órbitas.

```julia
n = 5               # iteraciones
X0 = rand(4) .+ 1.0 # x0 ∈ [1,2]
a = 10.0            # parámetro que ayuda a elegir los intervalos del plot
analisis_grafico(M2, X0[1], n, 
    (-a, a), 
    (M2(a),M2(-a)); 
    titulo = "Órbitas de F(x) = -x^5/5")#,
    #lab    = "$(X0[1])")
analisis_grafico!(M2, X0[2], n, :red2;   lab = "$(X0[2])")
analisis_grafico!(M2, X0[3], n, :green;  lab = "$(X0[3])")
analisis_grafico!(M2, X0[4], n, :purple; lab = "$(X0[4])")
```

En el caso de las condiciones iniciales $|x_0| > 1$ las órbitas divergen a $-\infty$ por lo que no se hallan más puntos fijos iterando y el único punto fijo (el cual es atractor) es $x = 0$.

* $ M_3(x) = \frac{x}{2} - 2 $

```julia
n = 10
X0 = 13*rand(4) .- 3.0 # x0 ∈ [-3,13]

analisis_grafico(M3, X0[1], n, 
    (-6, 1.2*maximum(X0)), 
    (-5, 2*maximum(M3.(X0))); 
    titulo = "Órbitas de F(x) = x/2 - 2")#,
    #lab = "$(X0[1])")
analisis_grafico!(M3, X0[2], n, :red2)#;   lab = "$(X0[2])")
analisis_grafico!(M3, X0[3], n, :green)#;  lab = "$(X0[3])")
analisis_grafico!(M3, X0[4], n, :purple)#; lab = "$(X0[4])")
```

Se observa que las órbitas con $x_0 > -3$ se ven atraídos por el punto fijo $x = 0$.

```julia
n = 5
X0 = -10*rand(4) .- 5.0 # x0 ∈ [-15,-5]

analisis_grafico(M3, X0[1], n, 
    (1.1*minimum(X0), -2.0), 
    (1.2*minimum(M3.(X0)), 1.0); 
    titulo = "Órbitas de F(x) = -x/2 - 2",
    lab    = "$(X0[1])")
analisis_grafico!(M3, X0[2], n, :red2;   lab = "$(X0[2])")
analisis_grafico!(M3, X0[3], n, :green;  lab = "$(X0[3])")
analisis_grafico!(M3, X0[4], n, :purple; lab = "$(X0[4])")
```

De igual manera, los puntos fijos con  $x_0 < -5$ convergen a un punto por lo que se puede concluir que existe un punto atractor en $[-5,-3]$.

Analíticamente, el punto fijo es:

$$ \frac{x}{2} - 2 = x \quad\Rightarrow\quad x = -4. $$

* $ M_4(x) = x - x^2 $

```julia
n = 15
X0 = rand(4) # x0 ∈ [0,1]

analisis_grafico(M4, X0[1], n, 
    (-0.3, 1.1),               
    (-0.2, 0.3);               
    titulo = "Órbitas de F(x) = x - x2", 
    lab    = "$(X0[1])")                 
analisis_grafico!(M4, X0[2], n, :red2;   lab = "$(X0[2])")
analisis_grafico!(M4, X0[3], n, :green;  lab = "$(X0[3])")
analisis_grafico!(M4, X0[4], n, :purple; lab = "$(X0[4])")
```

Se observa que las órbitas con $x_0 \in [0,1]$ se ven atraídos por el punto fijo $x = 0$.

```julia
n = 15
X0 = -5*rand(4) # x0 ∈ [-5,0]

analisis_grafico(M4, X0[1], n, 
    (-40, 30), 
    (-200, 20); 
    titulo = "Órbitas de F(x) = x - x2",
    lab    = "$(X0[1])")
analisis_grafico!(M4, X0[2], n, :red2;   lab = "$(X0[2])")
analisis_grafico!(M4, X0[3], n, :green;  lab = "$(X0[3])")
```

Para condiciones iniciales $x_0 > 1$ el valor de la función vuelve a ser negativo, por lo que como en el caso anterior, el siguiente iterado será "más negativo" y estas órbitas divergen a $-\infty$.

```julia
n = 15
X0 = 1.0 .+ 5*rand(4) # x0 ∈ [0,6]

analisis_grafico(M4, X0[1], n, 
    (-40, 30), 
    (-200, 20); 
    titulo = "Órbitas de F(x) = x - x^2",
    lab    = "$(X0[1])")
analisis_grafico!(M4, X0[2], n, :red2;   lab = "$(X0[2])")
analisis_grafico!(M4, X0[3], n, :green;  lab = "$(X0[3])")
```

Si la condición inicial es $x_0 < 0$, el primer iterado es negativo y para $x < 0$ la función es creciente, entonces un nuevo iterado dará un resultado "más negativo" que el anterior, por lo que la órbita diverge a $-\infty$ como se observa en la gráfica por lo que no se puede converger a otro punto fijo posiblemente atractor

El punto fijo es
$$ x - x^2 = x \quad\Rightarrow\quad x = 0$$

Gráficamente se nota que $x = 0$ es el único punto de intersección con la identidad por lo que es el único punto fijo. Asimismo, este punto es atractor para $x_0 \in [0,1]$ y repulsor para el resto.

## Ejercicio 2

(a) Consideren el mapeo $F(x) = x^2-2$ definido en $-2 \leq x \leq 2$. A partir de una condición al azar, construyan una órbita muy larga, por ejemplo, de $20\,000$ iterados o más. Obtengan el histograma de frecuencias (normalizado) que la órbita visita.

```julia
F(x) = x^2 - 2
```

```julia
x0 = 4*rand() .- 2   # x0 ∈ [-2,2] fijo
```

```julia
n = rand(1000:30000) # iteraciones
histogram(mapear(F, x0, n), bin = 800, normalize = true, 
    title = "Histograma de frecuencias. F(x) = x^2 - 2. n = $n", label = "")
```

(b) Repitan el ejercicio anterior para el mapeo $G(x) = 2x\text{ mod } 1$, definido en el intervalo $x\in[0,1]$.

```julia
G(x) = 2x%1
```

```julia
#x0 = rand()
#n = 1000
#analisis_grafico(G, x0, n, 
 #   (-0.1, 1.1), 
  #  (-0.1, 1.1); 
   # titulo = "Órbitas de F(x) = 2xmod1")#,
    #lab    = "$(x0)")
```

```julia
x0 = rand() # x0∈[0,1] fijo
```

```julia
n = rand(1000:30000) # iteraciones
histogram(mapear(G, x0, n), bin = 1000, normalize = true, label = "", ylims = (0,10),
    title = "Histograma de frecuencias. F(x) = 2x mod 1. n = 30,000")
```

(c) ¿Qué conclusión podemos sacar de los histogramas para ambos mapeos?

En ambos casos, el "bin" con mayores frecuencias son los más "visitados" por la sucesión de iteraciones de la función. Al reproducir numerosas veces con números aleatorios en el dominio de la función éstas regiones son:

* Para $F(x) = x^2 - 2$ y $1000$ bins: $[-2,-1.998]$ (bin 1), $[1.998,2]$ (bin 2).
* Para $G(x) = 2x\text{ mod }1$ y $1000$ bins: $[1.999,1]$ (bin 1).

En estas regiones hay puntos atractores y muy probablemente puntos fijos. 

## Ejercicio 3

(a) Usando lo que hicieron en la Tarea 1, incluyan lo que desarrollaron para los números `Dual` en un módulo `NumDual` de Julia ([ver la documentación aquí](https://docs.julialang.org/en/v1.3/manual/modules/)). En particular, el módulo debe exportar el tipo `Dual` y la función `var_dual`, al menos. El archivo con el módulo lo deben incluir en un archivo ".jl" en su propio directorio de tareas. Carguen el módulo en este notebook, usando

```julia
include("NumDual.jl")
```

```julia
using Main.NumDual
```

```julia
#Pkg.add("NumDual")
# using  NumDual
```

(b) Escriban una función que implemente el método de Newton para funciones en una dimensión. La derivada que se requiere debe ser calculada a través de los números duales. Obtengan un cero de $f(x) = x^3 - 8$, como test de que la implementación es correcta.

De la tarea 1 se tiene que `f(var_dual(x)) = (f(x), f'(x))`, así que `f'(x) = f(var_dual(x)).y`.

```julia
"""
newton(F::Function, x0::T; δ = 1/1000), {T <: Real} \n

Calcula las raíces de f por el método de newton desde un
punto inicial 'x0'; devuelve un vector de todas las 
aproximaciones hasta una tolerancia δ.
"""
function newton(F::Function, x0::T, δ = 1e-10) where {T <: Real} 
   
    # Vector de aproximaciones a la raiz de la función
    r = Float64[]
    x1 = x0 - F(x0)/F(var_dual(x0)).y
    push!(r, x0)
    push!(r, x1)
   
    j = 1 
    
    while abs(x1 - x0) > δ || j > 1000 # Si las aproximaciones no convergen, el
        x0 = x1                        # contador 'j' detiene el ciclo while
        x1 = x0 - F(x0)/F(var_dual(x0)).y
        push!(r, x1)
    end
    
    return r
    
end
```

```julia
"""
graph_newton(F::Function, R, xlim = (-20,20)), {T <: Real} \n

Hace una gráfica de la función y las aproximaciones sucesivas a la raíz.
"""

function graph_newton(F::Function, R, xlim = (-20,20)) where {T <: Real} 
   
    # Vector de aproximaciones a la raiz de la función
    vx = Float64[]
    vy = Float64[]
    raiz = Float64[]
    
    for i in 1 : length(R)-1
        push!(vx, R[i])
        push!(vx, R[i])
        push!(vx, R[i+1])
        push!(vy, zero(R[i]))
        push!(vy, F(R[i]))
        push!(vy, zero(R[i+1]))
    end

    p = plot(vx, vy, l = :dash, lc = :red, xlims = xlim, label = "")
    plot!(xlim[1]:1/100:xlim[2], F.(xlim[1]:1/100:xlim[2]), lc = :blue, l = 1.5, label = "f(x)")
    plot!(x -> 0, lc = :black, l = :dash, label = "")
    scatter!(R, zeros(length(R)), label = "aproxs. a la raíz")
    
    return p
end
```

```julia
# Punto inicial del método de Newton
x0 = 13.9
# Raíces de f(x) = x^3-8
graph_newton(x -> x^3 - 8, newton(x -> x^3 - 8, x0), (-5,15))
```

```julia
# Cero de la función
raiz = newton(x -> x^3 - 8, x0)[end]
```

(c) Encuentren los puntos fijos del mapeo $F(x) = x^2 - 1$ usando la función que implementaron para el método de Newton.

Los puntos fijos satisfacen $F(x) = x^2 - 1 = x$, esto es equivalente a calcular los ceros de $f(x) = x^2 - x - 1$.

```julia
# Graficamos la función para ver en dónde se encuentran los ceros para elegir x0.
F(x) = x^2 - x - 1
plot(F, xlims = (-4,5), label = "F(x)")
plot!(x -> 0, l = :dash, label = "")
```

```julia
# Raíz positiva, x0 = 4 
graph_newton(F, newton(F, 4), (-2,5))
```

```julia
# Raíz negativa # x0 = -3
graph_newton(F, newton(F, -3), (-4,3))
```

```julia
# Puntos fijos de F(x) = x^2 - 1.1
p_fijos = newton(F, 4)[end], newton(F, -3)[end]
```

(d) Encuentren las puntos *de periodo 2* para el mapeo $F(x) = x^2 - 1$ usando la función que implementaron para el método de Newton.

Los puntos de periodo 2 satisfacen $F^2(x) = x \; \Leftrightarrow \; (x^2 - 1)^2 - 1 = x$. Para hallar éstos hay que resolver $ h(x) = 0 \; \Leftrightarrow \; x^4 -x^2 - x$ = 0.

```julia
h(x) = x^4 - 2x^2 - x 
c = 2.0 # parámetro de ayuda para los límites del plot

plot(-c:1/100:c, h.(-c:1/100:c), xlims = (-c,c), label = "h(x)")
plot!(x -> 0, l = :dash, label = "")
```

* Raíz 1.

```julia
# Gráfica de la raíz 1.
x0 = -1.8
R1_h = newton(h, x0)
graph_newton(h, R1_h, (-2.0, -0.8))
```

* Raíz 2.

```julia
# Gráfica de la raíz 2.
x0 = -0.4
R2_h = newton(h, x0)
graph_newton(h, R2_h, (-0.7, 0.0))
```

* Raíz 3.

```julia
# Gráfica de la raíz 3.
x0 = -0.15
R3_h = newton(h, x0)
graph_newton(h, R3_h, (-0.4, 0.2))
```

* Raíz 4.

```julia
x0 = 2.0
R4_h = newton(h, x0)
graph_newton(h, R4_h, (1.5, 2.1))
```

```julia
# Puntos de periodo dos de F(x) = x^2 - 1.1
p_fijos = [R1_h[end], R2_h[end], R3_h[end], R4_h[end]]
```

(e) Usen números duales para mostrar que los puntos de periodo 2 para el mapeo $F(x) = x^2 -1$ son linealmente estables (atractivos).

Sabemos que si $x^*$ es  un punto fijo de $f$ y $|f'(x^*)| < 1$, entonces es linealmente estable. Veamos cómo se comporta la derivada de $|h'(x)| = |(F^2)'(x)|$ en los puntos fijos hallados.

```julia
# f'(x) = f(var_dual(x)).y

# Derivada de h
h_(x) = h(var_dual(x)).y
```

```julia
deriv_fijos = h_.(p_fijos) # evaluación de la derivada en los puntos fijos
```

```julia
# Comprobando estabilidad
abs.(deriv_fijos) .<= 1
```

Se observa que los tres primeros puntos fijos de periodo 2 son estables, mientras que el mayor de ellos es inestable.

## Ejercicio 4

(a) El método de Newton es iterativo, y en ese sentido se puede considerar como un mapeo dado por
\begin{equation}
z_{n+1} = N(z_n) = z_n - \frac{f(z_n)}{f'(z_n)}.
\end{equation}
Vamos a considerar la función $f(z) = z^3-1$, e iteraciones del mapeo $N(z)$, con $z\in\mathbb{C}$. Es claro que los ceros de $f(z)$, es decir, las $z^*$ tales que $f(z^*)=0$
tienen la propiedad de que $N(z^*)=z_*$. En este caso concreto los ceros los podemos escribir como $z^*_r = \exp(i 2\pi r/3)$, con $r=0, 1, 2$.

La idea es considerar *muchas* condiciones iniciales $z_0\in[-1,1]\times[-1,1]$, y para cada condición inicial iteraremos muchas veces el mapeo, por ejemplo, $n=10000$ veces. La idea es asignarle a cada condición inicial un color (azul, verde o rojo) según el punto al que converja, o al punto al que más se acerque $z_n$. Dibujen el mapa de colores que se obtiene.

```julia
# Mapeo N(z) = z - a*F(z)/'(z) para F(z) = z^3 - 1.
N(z, a) = (1 - a/3)*z + a/(3z^2)
```

```julia
# Raices (como vectores en R^2)
z1 = [1.0, 0.0]
z2 = [-0.5, sin(2*π/3)]
z3 = [-0.5, sin(4*π/3)]

# Para graficar el triángulo
zx = [z1[1], z2[1], z3[1], z1[1]]
zy = [z1[2], z2[2], z3[2], z1[2]]

# [-1,1]×[-1,1]
cx = [-1.0, 1.0, 1.0, -1.0, -1.0]
cy = [1.0, 1.0, -1.0, -1.0, 1.0];
```

```julia
"""
orb_complex(F :: Function, z0 :: Complex, n :: Int) \n

Devuelve un vector de la órbita que surge de 'n' iteraciones de la
función compleja 'F' con condición inicial 'z0'.
"""
function orb_complex(F::Function, z0::Complex, n::Int)
    Z = [z0]
    
    for i in 1:n
        z0 = F(z0)
        push!(Z, z0)
    end
    
    return Z
end
```

```julia
using LinearAlgebra # para la función norm()
```

```julia
"""
graf_orb_complex!(F :: Function, z0 :: Complex, n :: Int) \n

Permite sobreponer sobre una gráfica a la gráfica de un mapeo de 'n' iteraciones 
de la función compleja 'F' con condición inicial 'z0'.
"""
function graf_orb_complex!(F::Function, z0::Complex, n::Int, lin = :line) # lin es para el tipo de línea
    Z = orb_complex(F, z0, n)
    X = real.(Z)
    Y = imag.(Z)
    
    # iteración final
    zf = [X[end], Y[end]]
    
    if norm(zf-z1) < norm(zf-z2) && norm(zf-z1) < norm(zf-z3)
        color = :blue
    elseif norm(zf-z2) < norm(zf-z3)
        color = :red
    else
        color = :green
    end
    
    p = plot!(X, Y, lc = color, l = lin, label = "")
    scatter!([X[1]], [Y[1]], m = :star, mc = color, ms = 5, label = "")
    scatter!([zf[1]], [zf[2]], mc = color, ms = 7, label = "")
    
    return p
end
```

```julia
# m condiciones iniciales en [-1,1]×[-1,1]
m = 50
Z0 = [2*rand() - 1 + im*(2*rand() - 1) for i in 1:m];
```

```julia
α = 2.5 # para los intervalos de graficación

# Número de iteraciones
n = 25000

p = plot(zx, zy, l = 3, lc = :green1, grid = false, xlims = (-α, α), ylims = (-α, α), # triángulo
    label = "", xlabel = "Parte real", ylabel = "Parte imaginaria", aspectratio = 1,
     title = "Órbitas de N(z, a=1), f(z) = z^3 - 1")  
plot!(cx, cy, c = :yellow, l = 2, label = "")

for i in 1:m
    graf_orb_complex!(z -> N(z, 1), Z0[i], n)
end
p
```

En la gráfica anterior se muestra un triángulo con vértices las raíces de $f(z) = z^3 - 1$ y las distintas órbitas del mapeo $N(z)$. Las condiciones iniciales $z_0 \in [-1,1]\times[-1,1]$ están indicadas con estrellas y las iteraciones finales con círculos.

Las $40$ órbitas de prueba convergen a alguna de las raíces de $f(z)$.

Ahora observemos cómo se dividen los puntos del plano complejo de acuerdo a qué punto convergen.

```julia
"""
fractal_1(x::T, y::T, a, n = 1000) where {T <: Real} \n

Colorea una región del plano complejo z = x + iy en función del 
punto de convergencia de z como condición inicial de la órbita 
de N(z;a) = z - a*F(z)/F'(z) para F(z) = z^3 - 1. n es 
el número iteraciones de N. \n

Si la órbita converge a: \n

* z1: fractal_1(...) = 1. \n
* z2: fractal_1(...) = 2. \n
* z3: fractal_1(...) = 3. \n
"""

function fractal_1(x::T, y::T, a = 1.0, n = 1000) where {T <: Real}
    
    zf = orb_complex(z -> N(z,a), x + y*im, n)[end]
    zf = [real(zf), imag(zf)]
    
    if norm(zf - z1) < norm(zf - z2)
        return 1
    elseif norm(zf - z2) < norm(zf - z3)
        return 2
    else
        return 3
    end
    
end
```

Construyamos una función que ayude a visualizar las regiones según el punto de convergencia.

```julia
"""
mapeo_frac1(a = 1, ℓ = 1, n = 5000, Δ = 1/300) \n

Evalúa fractal_1 en el cuadrado [-ℓ,ℓ]×[-ℓ,ℓ] (con espaciado mínimo Δ).
"""

function mapeo_frac1(a = 1, ℓ = 1, n = 5000, Δ = 1/300)

    X = -ℓ:Δ:ℓ
    Y = -ℓ:Δ:ℓ
    
    # Matriz de valores de fractal_1([-1,1]×[-1,1]), se inicializa en ceros.
    M = zeros(length(X), length(Y));

    for i in 1:length(X)
        for j in 1:length(Y)
            M[i, j] = fractal_1(X[i], Y[j], a, n)
        end
    end
    
    return X, Y, M
    
end
```

```julia
# n = 5000
a, ℓ = 1, 1
X1, Y1, A1 = mapeo_frac1();
```

```julia
using Colors
```

```julia
heatmap(X1, Y1, A1, aspectratio = 1, c = cgrad([:darkblue, :purple, :aqua]), grid = false,
    title = "Mapa de colores para z en [-$ℓ,$ℓ]×[-$ℓ,$ℓ], a = $a")
```

(b) En el mismo espíritu que en el inciso (a), iteren muchas condiciones iniciales para el mapeo
\begin{equation}
z_{n+1} = N(z_n;\, a) = z_n - a\frac{f(z_n)}{f'(z_n)},
\end{equation}
para la misma función $f(z)$, con $a=2$.

*Nota:* Conviene guardar tres vectores (de condiciones iniciales), y a cada uno se le asignará un color. Para graficar, dado que estamos en los complejos, se graficará la parte real y la parte imaginaria de cada condición inicial.

Se observa que los puntos de convergencia vuelven a ser laas raíces de $z^3 -1$.

```julia
# a = 2, ℓ = 5, n = 2000
a, ℓ, n, Δ = 2, 6, 2000, 1/100
X2, Y2, A2 = mapeo_frac1(a, ℓ, n, Δ);
```

```julia
heatmap(X2, Y2, A2, aspectratio = 1, c = cgrad([:brown4, :brown1, :yellow]), grid = false,
    title = "Mapa de colores para z en [-$ℓ,$ℓ]×[-$ℓ,$ℓ], a = $a")
```

Se observa una estructura fractal con las proporciones de un triángulo equilátero.

## Ejercicio 5

Consideremos ahora el triángulo definido por los tres puntos $A=(0,1)$, $B=(\cos(7\pi/6),\, \sin(7\pi/6))$ y $C=(\cos(11\pi/6), \sin(11\pi/6))$, y *cualquier* otro punto $X_0 \, \in \, [-1,1]\times[-1,1]$. Consideraremos además un dado (no cargado) que usaremos para generar números aleatorios del 1 al 6 (con `rand(1:6)`).

(a) Definan una regla, la que quieran, que asigne dos salidas distintas del dado (por ejemplo, 1 y 5) a cada uno de los tres vértices del triángulo.

Regla de asignación: $1$ y $2$ para $A$, $3$ y $4$ para $B$, $5$ y $6$ para $C$.

(b) A partir de un punto $X$, definan el mapeo que, para cada tiro del dado $d$, hace que el punto $X$ sea mapeado al punto medio de $X$ y el vértice del triángulo asignado en (a).

```julia
sin(7*pi/6), sin(11*pi/6) # = -1/2
```

```julia
"""
map_dado(x0, A, B, C) \n

Calcula el punto medio entre x0 y A, B o C dependiendo del valor de dado = rand(1:6).\n

A: dado = 1, 2; B: dado = 3, 4; C: dado = 5, 6.
"""
function map_dado(X0, A, B, C) 
    
    dado = rand(1:6)
    
    if dado == 1 || dado == 2
        return [0.5*(X0[1] + A[1]), 0.5*(X0[2] + A[2])]
    elseif dado == 3 || dado == 4
        return [0.5*(X0[1] + B[1]), 0.5*(X0[2] + B[2])]
    elseif dado == 5 || dado == 6
        return [0.5*(X0[1] + C[1]), 0.5*(X0[2] + C[2])]
    end
    
end
```

```julia
# sin(7*π/6) = -0.5 = sin(11*π/6)
A, B, C = [0,1], [cos(7*π/6), -0.5], [cos(11*π/6), -0.5]
X0 = [2*rand().-1, 2*rand().-1] # (x,y) ∈ [-1,1]×[-1,1]
```

```julia
# Gráfica del triángulo y del primer iterado
p = plot([A[1], B[1], C[1], A[1]], [A[2], B[2], C[2], A[2]],
    l = 3, lc = :green2, label = "", grid = false,
    xlims = (-1.1,1.1), ylims = (-1.1,1.1), aspectratio = 1, 
    title = "Triángulo de Sierpinski")
plot!(cx, cy, l = 2, lc = :yellow, label = "")
scatter!([X0[1]], [X0[2]], m = :star, ms = 8, label = "x_0")
```

```julia
# Gráfica de las iteraciones en 2D
n = 10000
for i in 1:n
    Q = map_dado(X0, A, B, C)
    plot!([Q[1]], [Q[2]], label = "", m = :circle, ms = 0.5, l = 0)
    #scatter!([Q[1]], [Q[2]], label = "", m = :circle, ms = 0.5)
    X0 = Q
end
p
```

(c) Obtengan *el atractor* del mapeo para una sola condición inicial, esto es, iteren muchísimas veces el mapeo ($n=100000$) y pinten la secuencia de los iterados.

La gráfica de las iteraciones se hizo con $n = 1000$. Analicemos cuales son los atractores del mapeo para n = 100,000.


```julia
m = 10000 # iteraciones
M = [map_dado(X0, A, B, C) for i in 1:m] # vector de vectores 2D del mapeo
Mx = Float64[] # abcisas del mapeo
My = Float64[] # ordenadas del mapeo
```

```julia
for i in 1:m
    push!(Mx, M[i][1])
    push!(My, M[i][2])
end
```

```julia
# histograma en 2d
histogram2d(Mx, My, bins = 30, c = cgrad([:darkblue, :aqua, :green2]))
#scatter!(A, B, C)
```

Del histograma 2d se obserba que los puntos iterados se concentran en los vértices del triángulo, por lo que podemos decir que éstos son puntos atractores.

```julia
#plot(1:m, Mx, l = 0, m = :circle, ms = 1, xlims = (0,10000), label = "")
```

```julia
#plot(1:m, N, My, l = 0, m = :circle, ms = 1, xlims = (0,10000), label = "")
```

Se observan tres valores atractores para las abcisas y dos para las ordenadas.

* Abscisas

(d) ¿Qué pasa si empiezan con otras condiciones iniciales, incluso fuera de $[-1,1]\times[-1,1]$?

```julia
"""
X0_5() \n

Devuelve un vector [x,y] elegido aleatoriamente en [-5,5]^2 - [-1,1]^2
"""
function X0_5()
    x, y = 10*rand() .- 5, 10*rand() .- 5
    
    while -1 < x && x < 1 && -1 < y && y < 1
        x, y = 10*rand() .- 5, 10*rand() .- 5
    end
    
    return [x,y]
end
```

```julia
X0 = X0_5()
```

```julia
# Gráfica del triángulo y la condición inicial
q = plot([A[1], B[1], C[1], A[1]], [A[2], B[2], C[2], A[2]],
    l = 2, lc = :green2, label = "", grid = false,
    xlims = (-1.5,1.5), ylims = (-1.5,1.5), aspectratio = 1, 
    title = "Triángulo de Sierpinski")
plot!(cx, cy, l = 2, lc = :yellow)
scatter!([X0[1]], [X0[2]], m = :star, ms = 8, label = "X0")
```

```julia
# Gráfica de las iteraciones en 2D
n = 10000
for i in 1:n
    Q = map_dado(X0, A, B, C)
    scatter!([Q[1]], [Q[2]], label = "", m = :circle, ms = 0.5)
    X0 = Q
end
q
```

Se observa que, al menos con condiciones iniciales $ x_0 \in [-5,5]^2 - [-1,1]^2 $, los puntos de la órbita aún describen el triángulo de Sierpinski.

## Ejercicio 6

Vamos a considerar el siguiente mapeo lineal, en dos dimensiones, dado por

\begin{equation}
B(x_{n}, y_{n} ) =
\left( \begin{array}{c} x_{n+1} \\ y_{n+1} \end{array} \right) =
\left(\begin{array}{cc} a & b\\ c & d \end{array}\right)
\left( \begin{array}{c} x_{n} \\ y_{n} \end{array} \right) +
\left( \begin{array}{c} 0 \\ f \end{array} \right).
\end{equation}

Los coeficientes que aparecen en el mapeo se eligirán de manera aleatoria, con
probabilidad $p$, de acuerdo con la siguiente tabla:

|     p     |     a     |     b     |     c     |     d     |     f     |
|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|
|   0.01    |     0     |     0     |     0     |    0.16   |   0    |
|   0.85    |  0.85     |     0.04  |   -0.04   |    0.85   |   1.6     |
|   0.07    |  0.2      |    -0.26  |    0.23   |    0.22   |   1.6     |
|   0.07    | -0.15     |     0.28  |    0.26   |    0.24   |   0.44    |

Dibujen (en verde, usando `markerstrokecolor=:green`) el atractor del mapeo.

```julia
using StatsBase # para usar sample()
```

```julia
proba = ProbabilityWeights([0.01, 0.85, 0.07, 0.07]) # guarda los valores de p
```

```julia
a = sample([0.0 ,  0.85,  0.2 , -0.15], proba)
b = sample([0.0 ,  0.04, -0.26,  0.28], proba)
c = sample([0.0 , -0.04,  0.23,  0.26], proba)
d = sample([0.16,  0.85,  0.22,  0.24], proba)
f = sample([0.0 ,  1.6 ,  1.6 ,  0.44], proba)

# Mapeo 2D
B1(X) = [a*X[1] + b*X[2], c*X[2] + d*X[2] + f]
```

```julia
# iteraciones
function map_B1(X0, n)
    X, Y = [X0[1]], [X0[2]]

    for i in 1:n
        X0 = B1(X0)
        push!(X, X0[1])
        push!(Y, X0[2])
    end
    
    return X, Y
end
```

```julia
n = 5000
m = 2000 # número de condiciones iniciales

pp = plot(grid = false, label = "", aspectratio = 1,
    title = "Mapeo B. El círculo es el punto atractor.")#,
    #xlims = (-r,r), ylims = (-r,r))

for i in 1:m
    X0 = [21*rand() - 8, 16*rand()]
    xx, yy = map_B1(X0, n)
    plot!(xx, yy, label = "")
    scatter!([xx[1]],   [yy[1]],   m = :star, label = "")
    scatter!([xx[end]], [yy[end]], m = :circle, mc = :green, ms = 5, label = "")
end
pp
```

```julia
```
